// lib/cache/cache-config.ts - Configuration for caching strategies

// Types for different cache options
export enum CacheType {
  MEMORY = 'memory',
  LOCAL_STORAGE = 'localStorage',
  SESSION_STORAGE = 'sessionStorage',
}

// Time units in milliseconds
export const TIME = {
  SECOND: 1000,
  MINUTE: 60 * 1000,
  HOUR: 60 * 60 * 1000,
  DAY: 24 * 60 * 60 * 1000,
};

// Cache configuration by resource type
export const CACHE_CONFIG = {
  // Product details
  product: {
    type: CacheType.MEMORY,
    staleTime: TIME.HOUR, // Product data stays fresh for 1 hour
    cacheTime: TIME.DAY, // Keep in cache for 1 day
  },
  
  // Category listings
  productList: {
    type: CacheType.MEMORY,
    staleTime: TIME.MINUTE * 30, // Lists stay fresh for 30 minutes
    cacheTime: TIME.HOUR * 6, // Keep in cache for 6 hours
  },
  
  // Categories and taxonomies
  categories: {
    type: CacheType.LOCAL_STORAGE,
    staleTime: TIME.HOUR * 12, // Categories rarely change
    cacheTime: TIME.DAY * 7, // Keep for a week
  },
  
  // User-specific cart data
  cart: {
    type: CacheType.SESSION_STORAGE, // Use session storage for cart
    staleTime: TIME.MINUTE * 5, // Cart data stays fresh for 5 minutes
    cacheTime: TIME.HOUR, // Keep cart cached for 1 hour
  },
  
  // User authentication
  auth: {
    type: CacheType.LOCAL_STORAGE,
    staleTime: TIME.HOUR * 2, // Auth tokens stay fresh for 2 hours
    cacheTime: TIME.DAY, // Keep auth data for 1 day
  },
  
  // User profile data
  user: {
    type: CacheType.LOCAL_STORAGE,
    staleTime: TIME.HOUR * 6, // User data stays fresh for 6 hours
    cacheTime: TIME.DAY * 3, // Keep for 3 days
  },
  
  // App settings and preferences
  settings: {
    type: CacheType.LOCAL_STORAGE,
    staleTime: TIME.DAY, // Settings stay fresh for a day
    cacheTime: TIME.DAY * 30, // Keep for a month
  },
};

// lib/cache/cache-manager.ts - Implementation of caching logic

type CacheOptions = {
  type: CacheType;
  staleTime: number;
  cacheTime: number;
};

type CacheItem<T> = {
  data: T;
  timestamp: number;
  expiry: number;
};

class CacheManager {
  private memoryCache: Map<string, CacheItem<any>> = new Map();
  
  // Get item from the appropriate cache
  async get<T>(key: string, options: CacheOptions): Promise<T | null> {
    const now = Date.now();
    let cacheItem: CacheItem<T> | null = null;
    
    // Try to get from the appropriate cache
    switch (options.type) {
      case CacheType.MEMORY:
        cacheItem = this.memoryCache.get(key) as CacheItem<T> || null;
        break;
        
      case CacheType.LOCAL_STORAGE:
        try {
          const stored = localStorage.getItem(key);
          if (stored) {
            cacheItem = JSON.parse(stored) as CacheItem<T>;
          }
        } catch (e) {
          console.warn('Error reading from localStorage:', e);
        }
        break;
        
      case CacheType.SESSION_STORAGE:
        try {
          const stored = sessionStorage.getItem(key);
          if (stored) {
            cacheItem = JSON.parse(stored) as CacheItem<T>;
          }
        } catch (e) {
          console.warn('Error reading from sessionStorage:', e);
        }
        break;
    }
    
    // If no cached item found, return null
    if (!cacheItem) {
      return null;
    }
    
    // If cache has expired, remove it and return null
    if (now > cacheItem.expiry) {
      this.remove(key, options.type);
      return null;
    }
    
    // Return data, indicating if it's stale
    const isStale = now - cacheItem.timestamp > options.staleTime;
    return cacheItem.data;
  }
  
  // Store item in the appropriate cache
  async set<T>(key: string, data: T, options: CacheOptions): Promise<void> {
    const now = Date.now();
    const cacheItem: CacheItem<T> = {
      data,
      timestamp: now,
      expiry: now + options.cacheTime,
    };
    
    switch (options.type) {
      case CacheType.MEMORY:
        this.memoryCache.set(key, cacheItem);
        break;
        
      case CacheType.LOCAL_STORAGE:
        try {
          localStorage.setItem(key, JSON.stringify(cacheItem));
        } catch (e) {
          console.warn('Error writing to localStorage:', e);
          // Try to recover by clearing some space
          this.clearOldCache(CacheType.LOCAL_STORAGE);
          try {
            localStorage.setItem(key, JSON.stringify(cacheItem));
          } catch (e) {
            console.error('Failed to write to localStorage even after clearing space');
          }
        }
        break;
        
      case CacheType.SESSION_STORAGE:
        try {
          sessionStorage.setItem(key, JSON.stringify(cacheItem));
        } catch (e) {
          console.warn('Error writing to sessionStorage:', e);
          // Try to recover
          this.clearOldCache(CacheType.SESSION_STORAGE);
          try {
            sessionStorage.setItem(key, JSON.stringify(cacheItem));
          } catch (e) {
            console.error('Failed to write to sessionStorage even after clearing space');
          }
        }
        break;
    }
  }
  
  // Remove item from the appropriate cache
  remove(key: string, type: CacheType): void {
    switch (type) {
      case CacheType.MEMORY:
        this.memoryCache.delete(key);
        break;
        
      case CacheType.LOCAL_STORAGE:
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.warn('Error removing from localStorage:', e);
        }
        break;
        
      case CacheType.SESSION_STORAGE:
        try {
          sessionStorage.removeItem(key);
        } catch (e) {
          console.warn('Error removing from sessionStorage:', e);
        }
        break;
    }
  }
  
  // Clear all expired items from a specific cache
  clearOldCache(type: CacheType): void {
    const now = Date.now();
    
    switch (type) {
      case CacheType.MEMORY:
        for (const [key, item] of this.memoryCache.entries()) {
          if (now > item.expiry) {
            this.memoryCache.delete(key);
          }
        }
        break;
        
      case CacheType.LOCAL_STORAGE:
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('cache:')) {
              const item = JSON.parse(localStorage.getItem(key)!);
              if (now > item.expiry) {
                localStorage.removeItem(key);
              }
            }
          }
        } catch (e) {
          console.warn('Error clearing old localStorage cache:', e);
        }
        break;
        
      case CacheType.SESSION_STORAGE:
        try {
          for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key && key.startsWith('cache:')) {
              const item = JSON.parse(sessionStorage.getItem(key)!);
              if (now > item.expiry) {
                sessionStorage.removeItem(key);
              }
            }
          }
        } catch (e) {
          console.warn('Error clearing old sessionStorage cache:', e);
        }
        break;
    }
  }
  
  // Clear all cache
  clearAll(): void {
    // Clear memory cache
    this.memoryCache.clear();
    
    // Clear localStorage cache
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('cache:')) {
          localStorage.removeItem(key);
        }
      }
    } catch (e) {
      console.warn('Error clearing localStorage cache:', e);
    }
    
    // Clear sessionStorage cache
    try {
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key && key.startsWith('cache:')) {
          sessionStorage.removeItem(key);
        }
      }
    } catch (e) {
      console.warn('Error clearing sessionStorage cache:', e);
    }
  }
  
  // Generate a standardized cache key
  generateKey(namespace: string, id: string | number): string {
    return `cache:${namespace}:${id}`;
  }
}

// Export singleton instance
export const cacheManager = new CacheManager();

// Example of using the cache for product fetching - lib/products/product-service.ts

import { Product } from '@/types/product';
import { cacheManager, CACHE_CONFIG } from '@/lib/cache';
import { fetchProduct, ProductIdTypeEnum } from '@/graphql';

export async function getProduct(
  slug: string,
  options = { skipCache: false, forceFresh: false }
): Promise<Product | null> {
  const cacheKey = cacheManager.generateKey('product', slug);
  const config = CACHE_CONFIG.product;
  
  // Try to get from cache if not skipping cache
  if (!options.skipCache) {
    const cachedProduct = await cacheManager.get<Product>(cacheKey, config);
    if (cachedProduct && !options.forceFresh) {
      return cachedProduct;
    }
  }
  
  // Fetch fresh data
  try {
    const product = await fetchProduct(slug, ProductIdTypeEnum.SLUG);
    
    if (product) {
      // Store in cache
      await cacheManager.set(cacheKey, product, config);
      return product;
    }
    
    return null;
  } catch (error) {
    console.error('Error fetching product:', error);
    // If fetch fails but we have cached data, return it as fallback
    if (!options.skipCache) {
      const cachedProduct = await cacheManager.get<Product>(cacheKey, config);
      if (cachedProduct) {
        console.log('Using cached product data as fallback');
        return cachedProduct;
      }
    }
    return null;
  }
}

// Example of using the cache with React Query in a component
// hooks/useProduct.ts

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getProduct } from '@/lib/products/product-service';
import { cacheManager, CACHE_CONFIG } from '@/lib/cache';

export function useProduct(slug: string) {
  const queryClient = useQueryClient();
  
  return useQuery({
    queryKey: ['product', slug],
    queryFn: () => getProduct(slug),
    staleTime: CACHE_CONFIG.product.staleTime,
    gcTime: CACHE_CONFIG.product.cacheTime,
    // Implement network status logic for prefetching
    networkMode: 'offlineFirst', 
    
    // Use cache manager for additional persistence
    initialData: () => {
      // Try to get from our custom cache
      const cacheKey = cacheManager.generateKey('product', slug);
      return cacheManager.get(cacheKey, CACHE_CONFIG.product);
    },
    onSuccess: (data) => {
      // Update our custom cache
      if (data) {
        const cacheKey = cacheManager.generateKey('product', slug);
        cacheManager.set(cacheKey, data, CACHE_CONFIG.product);
      }
    },
  });
}

// Service Worker for offline support
// public/service-worker.js

/* 
// This would go in a file at public/service-worker.js
const CACHE_NAME = 'damned-designs-cache-v1';
const RUNTIME_CACHE = 'runtime-v1';

// Resources to cache immediately on install
const PRECACHE_URLS = [
  '/',
  '/shop',
  '/offline.html',
  '/favicon.ico',
  '/manifest.json',
  '/static/css/main.css',
  '/static/js/main.js',
];

// Install event - precache static resources
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(PRECACHE_URLS);
    })
  );
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  const currentCaches = [CACHE_NAME, RUNTIME_CACHE];
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return cacheNames.filter((cacheName) => !currentCaches.includes(cacheName));
    }).then((cachesToDelete) => {
      return Promise.all(cachesToDelete.map((cacheToDelete) => {
        return caches.delete(cacheToDelete);
      }));
    }).then(() => self.clients.claim())
  );
});

// Fetch event - network-first with fallback to cache
self.addEventListener('fetch', (event) => {
  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }
  
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }
  
  // For API requests, use network first with cache fallback
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Clone the response to store in cache
          const responseToCache = response.clone();
          
          caches.open(RUNTIME_CACHE)
            .then((cache) => {
              // Only cache successful responses
              if (response.status === 200) {
                cache.put(event.request, responseToCache);
              }
            });
          
          return response;
        })
        .catch(() => {
          // If network request fails, try to get from cache
          return caches.match(event.request)
            .then((cachedResponse) => {
              if (cachedResponse) {
                return cachedResponse;
              }
              
              // If not in cache and we're offline, return a generic offline response
              // for API requests
              return caches.match('/offline-api.json');
            });
        })
    );
    return;
  }
  
  // For navigation and page requests, use cache-first with network fallback
  if (event.request.mode === 'navigate' || event.request.headers.get('accept').includes('text/html')) {
    event.respondWith(
      caches.match(event.request)
        .then((cachedResponse) => {
          if (cachedResponse) {
            // Update the cache in the background
            fetch(event.request)
              .then((response) => {
                if (response.status === 200) {
                  caches.open(CACHE_NAME).then((cache) => {
                    cache.put(event.request, response);
                  });
                }
              })
              .catch(() => {/* Ignore fetch errors */});
            
            return cachedResponse;
          }
          
          // If not in cache, try network
          return fetch(event.request)
            .then((response) => {
              // Cache the response
              if (response.status === 200) {
                const responseToCache = response.clone();
                caches.open(CACHE_NAME).then((cache) => {
                  cache.put(event.request, responseToCache);
                });
              }
              
              return response;
            })
            .catch(() => {
              // If offline, show offline page
              return caches.match('/offline.html');
            });
        })
    );
    return;
  }
  
  // For images, CSS, JS, etc., use cache-first strategy
  if (
    event.request.headers.get('accept').includes('image') ||
    event.request.url.endsWith('.css') ||
    event.request.url.endsWith('.js') ||
    event.request.url.includes('/static/')
  ) {
    event.respondWith(
      caches.match(event.request)
        .then((cachedResponse) => {
          if (cachedResponse) {
            return cachedResponse;
          }
          
          return fetch(event.request)
            .then((response) => {
              // Clone the response to store in cache
              const responseToCache = response.clone();
              
              if (response.status === 200) {
                caches.open(RUNTIME_CACHE)
                  .then((cache) => {
                    cache.put(event.request, responseToCache);
                  });
              }
              
              return response;
            })
            .catch(() => {
              // If it's an image, return a placeholder
              if (event.request.headers.get('accept').includes('image')) {
                return caches.match('/placeholder-image.png');
              }
              
              // Otherwise just fail gracefully
              return new Response('Resource not available offline', {
                status: 503,
                statusText: 'Service Unavailable',
                headers: new Headers({
                  'Content-Type': 'text/plain'
                })
              });
            });
        })
    );
    return;
  }
  
  // For all other requests, try network then cache
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Cache successful responses
        if (response.status === 200) {
          const responseToCache = response.clone();
          caches.open(RUNTIME_CACHE)
            .then((cache) => {
              cache.put(event.request, responseToCache);
            });
        }
        
        return response;
      })
      .catch(() => {
        return caches.match(event.request);
      })
  );
});

// Clean up old cached responses periodically
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'cache-cleanup') {
    event.waitUntil(
      caches.open(RUNTIME_CACHE).then((cache) => {
        return cache.keys().then((requests) => {
          return Promise.all(
            requests.map((request) => {
              // Get the response and check its Date header
              return cache.match(request).then((response) => {
                if (!response) return cache.delete(request);
                
                const dateHeader = response.headers.get('date');
                if (!dateHeader) return cache.delete(request);
                
                const cacheTime = new Date(dateHeader).getTime();
                const now = new Date().getTime();
                
                // If older than 30 days, delete from cache
                if (now - cacheTime > 30 * 24 * 60 * 60 * 1000) {
                  return cache.delete(request);
                }
                
                return Promise.resolve();
              });
            })
          );
        });
      })
    );
  }
});
